#!/usr/bin/env python3
import argparse
import logging
import struct
import sys
from functools import reduce

# sudo -H python3 -m pip install pycryptodomex
from Cryptodome.Cipher import ARC4

__author__ = "Sandor Nemes"


log = logging.getLogger(__name__)

MZ_HEADER = bytes.fromhex(
    '4d5a90000300000004000000ffff0000b800000000000000400000000000'
    '000000000000000000000000000000000000000000000000000000000000'
    '800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d'
    '2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a'
    '2400000000000000'
)

PE32_HEADER = MZ_HEADER + bytes.fromhex(
    '504500004c010500000000000000000000000000e00002210b0108000064'
    '010000e4020000000000b671010000100000008001000000001000100000'
    '000200000400000000000000040000000000000000800500000400000000'
    '000002000004000010000010000000001000001000000000000010000000'
)

PE64_HEADER = MZ_HEADER + bytes.fromhex(
    '5045000064860500000000000000000000000000f00022200b02090000aa'
    '000000280000000000009c44000000100000000000800100000000100000'
    '000200000500020000000000050002000000000000200100000400000000'
    '000002000000000010000000000000100000000000000000100000000000'
    '00100000000000000000000010000000'
)

SECTION_NAMES = {
    32: ['.text', '.rdata', '.data', '.reloc'],
    64: ['.text', '.rdata', '.data', '.pdata', '.reloc'],
}


def fnv1a_hash(s):
    return reduce(lambda h, c: (0x1000193 * (h ^ c)) & 0xffffffff, s, 0x811c9dc5)


def round_up(value, alignment):
    value += alignment - 1
    value -= value % alignment
    return value


def decrypt_payload(data):
    assert struct.unpack_from('=I', data, 0x57)[0] == 0x54414449

    bufsize = struct.unpack_from('>I', data, 0x53)[0]
    assert bufsize < len(data)

    log.info('[+] Buffer size: %d', bufsize)
    data = data[0x5b:0x5b + bufsize]

    checksum, key_size = struct.unpack_from('=IB', data)
    log.info('[+] Checksum: %d', checksum)
    log.info('[+] RC4 key size: %d', key_size)

    if key_size > 0:
        rc4_key, data = data[5:5 + key_size], data[5 + key_size:]
        log.info('[+] RC4 key: %s', rc4_key.hex())
        log.info('[+] Decrypting...')
        data = ARC4.new(rc4_key).decrypt(data)
        assert fnv1a_hash(data) == checksum
        return data

    # key size == 0 -> encrypted using the bot ID
    rc4_key, data = None, data[5:]
    for i in range(0x800000):
        if i % 1000000 == 0:
            log.info('[+] Encrypted using bot ID, brute-forcing... %d%%', (100 * i) >> 23)

        i = struct.pack('=I', i << 8)
        tmp = ARC4.new(i).decrypt(data[:4])

        if tmp[0] != 0x03 or tmp[3] != 0x00:
            continue

        tmp = ARC4.new(i).decrypt(data)
        if fnv1a_hash(tmp) != checksum:
            continue

        rc4_key, data = i, tmp
        log.info('[+] Encrypted using bot ID, brute-forcing... found :)')
        log.info('[+] RC4 key: %s', rc4_key.hex())
        break

    if not rc4_key:
        log.info('[+] Encrypted using bot ID, brute-forcing... not found :(')
        data = None

    return data


def reconstruct_dlls(data):
    magic, size, loader32, loader64, header32, header64 = struct.unpack_from('=IIIIII', data)
    assert len(data) == size

    log.debug('---')
    log.debug('Magic: %#010x', magic)
    log.debug('Size: %#010x', size)
    log.debug('Loader32: %#010x', loader32)
    log.debug('Loader64: %#010x', loader64)
    log.debug('Header32: %#010x', header32)
    log.debug('Header64: %#010x', header64)

    for header in (header32, header64):
        if header == header32:
            arch = 32
        elif header == header64:
            arch = 64
        assert arch in (32, 64)

        image_base, size_of_image, entry_point, import_rva, fixups_rva, fixups_size, num_sections = struct.unpack_from('=QIIIIII', data, header)

        log.debug('---')
        log.debug('ImageBase: %#010x', image_base)
        log.debug('SizeOfImage: %#010x', size_of_image)
        log.debug('EntryPoint: %#010x', entry_point)
        log.debug('Import RVA: %#010x', import_rva)
        log.debug('Fixups RVA: %#010x', fixups_rva)
        log.debug('Fixups size: %#010x', fixups_size)
        log.debug('Number of sections: %#010x', num_sections)
        log.debug('---')

        sections = {}
        for i in range(num_sections):
            pos = 0x11*i + 0x20
            virtual_address, virtual_size, physical_offset, physical_size, flags = struct.unpack_from('=IIIIB', data, header + pos)

            start = header + physical_offset
            end = start + physical_size
            sections[virtual_address] = {
                'virtual_size': virtual_size,
                'virtual_address': virtual_address,
                'physical_size': physical_size,
                'physical_offset': physical_offset,
                'section_flags': flags,
                'section_data': data[start:end],
            }

        if arch == 32:
            PE_HEADER = PE32_HEADER
            section_offset = 0x178
        elif arch == 64:
            PE_HEADER = PE64_HEADER
            section_offset = 0x188

        size_of_code = 0
        size_of_init_data = 0
        size_of_uninit_data = 0
        import_size = 0

        # reconstruct PE file
        pefile = bytearray(PE_HEADER.ljust(0x400, b'\0'))

        next_rva = 0x1000
        for i, rva in enumerate(sorted(sections)):
            section = sections[rva]
            virtual_size = section['virtual_size']
            virtual_address = section['virtual_address']
            physical_size = section['physical_size']
            physical_offset = len(pefile)
            section_flags = section['section_flags']
            section_data = section['section_data']

            if next_rva < virtual_address:
                log.warning('[!] WARNING: PE sections are not contiguous')

            log.debug('Virtual address: %#010x', virtual_address)
            log.debug('Virtual size: %#010x', virtual_size)
            log.debug('Physical address: %#010x', physical_offset)
            log.debug('Physical size: %#010x', physical_size)
            log.debug('Flags: %#010x', section_flags)
            log.debug('---')

            if i == 0:
                # base of code
                struct.pack_into('=I', pefile, 0xac, virtual_address)
            elif i == 1 and arch == 32:
                # base of data
                struct.pack_into('=I', pefile, 0xb0, virtual_address)

            section_name = SECTION_NAMES[arch][i]
            if section_flags == 0x20:
                # read/execute, code
                section_flags = 0x60000020
            elif section_flags == 0x04:
                if section_name in ('.rdata', '.pdata', '.reloc'):
                    # read only, init data
                    section_flags = 0x40000040
                else:
                    # read/write, init data
                    section_flags = 0xc0000040
            else:
                # read/write, uninit data
                section_flags = 0xc0000080

            if section_flags & 0x20:
                size_of_code += round_up(virtual_size, 0x200)
            if section_flags & 0x40:
                size_of_init_data += round_up(virtual_size, 0x200)
            if section_flags & 0x80:
                size_of_uninit_data += round_up(virtual_size, 0x200)

            struct.pack_into('=8sIIIIIIHHI', pefile, section_offset + 0x28*i,
                section_name.encode().ljust(8, b'\0'),
                virtual_size,
                virtual_address,
                physical_size,
                physical_offset,
                0, 0, 0, 0,
                section_flags
            )

            pefile += bytearray(section_data.ljust(round_up(physical_size, 0x200), b'\0'))
            next_rva += round_up(virtual_size, 0x1000)

            if virtual_address <= import_rva < next_rva:
                # calculate import directory size
                import_size = round_up(len(section_data[import_rva - virtual_address:].split(b'\0' * 0x14, 1)[0]) + 0x14, 0x14)

        struct.pack_into('=H', pefile, 0x86, num_sections)
        struct.pack_into('=I', pefile, 0x9c, size_of_code)
        struct.pack_into('=I', pefile, 0xa0, size_of_init_data)
        struct.pack_into('=I', pefile, 0xa4, size_of_uninit_data)
        struct.pack_into('=I', pefile, 0xa8, entry_point)

        if arch == 32:
            struct.pack_into('=I', pefile, 0xb4, image_base)
            struct.pack_into('=II', pefile, 0x100, import_rva, import_size)
            struct.pack_into('=II', pefile, 0x120, fixups_rva, fixups_size)
        elif arch == 64:
            struct.pack_into('=Q', pefile, 0xb0, image_base)
            struct.pack_into('=II', pefile, 0x110, import_rva, import_size)
            struct.pack_into('=II', pefile, 0x130, fixups_rva, fixups_size)

        struct.pack_into('=I', pefile, 0xd0, size_of_image)

        yield arch, pefile


def main():
    parser = argparse.ArgumentParser(description='Decrypts IcedID from PNG image files downloaded by the IcedID loader component')
    parser.add_argument('filename', nargs='?', default='photo.png', help='PNG image file')
    parser.add_argument('-d', '--debug', action='store_true', help='Debug logging')
    args = parser.parse_args()

    logging.basicConfig(format='%(message)s', level=(logging.INFO, logging.DEBUG)[args.debug], stream=sys.stderr)

    log.info('[+] Input file: %s', args.filename)
    with open(args.filename, 'rb') as f:
        data = f.read()

    data = decrypt_payload(data)

    filename = args.filename + '.decrypted'
    log.info('[+] Saving decrypted shellcode: %s', filename)
    with open(filename, 'wb') as f:
        f.write(data)

    payload_type = {3: 'BACKGROUND.PNG'}.get(data[0], 'PHOTO.PNG')
    log.info('[+] Payload type: %s', payload_type)

    if payload_type == 'BACKGROUND.PNG':
        (
            shellcode_size, shellcode_offset, shellcode_code_size,
            is_dll,
            pefile_size, pefile_offset,
            file_ext,
            virtual_alloc, virtual_protect, create_process, load_library
        ) = struct.unpack_from('=IIIBII8s16s16s16s16s', data, 1)
        file_ext = file_ext.decode().rstrip('\0')
        log.info('[+] Shellcode size: %d', shellcode_size)
        log.info('[+] Shellcode offset: %#010x', shellcode_offset)
        log.info('[+] Shellcode code size: %d', shellcode_code_size)
        log.info('[+] PE file type: %s', ('EXE', 'DLL')[bool(is_dll)])
        log.info('[+] PE file size: %d', pefile_size)
        log.info('[+] PE file offset: %#010x', pefile_offset)
        log.info('[+] File extension: %s', file_ext)
        assert virtual_alloc.decode().rstrip('\0') == 'VirtualAlloc'
        assert virtual_protect.decode().rstrip('\0') == 'VirtualProtect'
        assert create_process.decode().rstrip('\0') == 'CreateProcessA'
        assert load_library.decode().rstrip('\0') == 'LoadLibraryA'
        pefile = data[pefile_offset : pefile_offset + pefile_size]
        filename = 'icedid_loader_packed.' + file_ext
        log.info('[+] Saving extracted loader: %s', filename)
        with open(filename, 'wb') as f:
            f.write(pefile)
    else:
        for arch, pefile in reconstruct_dlls(data):
            filename = 'icedid{!s}.dll'.format(arch)
            log.info('[+] Saving reconstructed %d-bit payload: %s', arch, filename)
            with open(filename, 'wb') as f:
                f.write(pefile)


if __name__ == '__main__':
    main()
