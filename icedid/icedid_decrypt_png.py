#!/usr/bin/env python3
import argparse
import struct

# sudo -H python3 -m pip install pycryptodomex
from Cryptodome.Cipher import ARC4

__author__ = "Sandor Nemes"


MZ_HEADER = bytes.fromhex(
    '4d5a90000300000004000000ffff0000b800000000000000400000000000'
    '000000000000000000000000000000000000000000000000000000000000'
    '800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d'
    '2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a'
    '2400000000000000'
)

PE32_HEADER = MZ_HEADER + bytes.fromhex(
    '504500004c010500000000000000000000000000e00002210b0108000064'
    '010000e4020000000000b671010000100000008001000000001000100000'
    '000200000400000000000000040000000000000000800500000400000000'
    '000002000004000010000010000000001000001000000000000010000000'
)

PE64_HEADER = MZ_HEADER + bytes.fromhex(
    '5045000064860500000000000000000000000000f00022200b02090000aa'
    '000000280000000000009c44000000100000000000800100000000100000'
    '000200000500020000000000050002000000000000200100000400000000'
    '000002000000000010000000000000100000000000000000100000000000'
    '00100000000000000000000010000000'
)

SECTION_NAMES = {
    32: ['.text', '.rdata', '.data', '.reloc'],
    64: ['.text', '.rdata', '.data', '.pdata', '.reloc'],
}


def round_up(value, alignment):
    value += alignment - 1
    value -= value % alignment
    return value

def main():
    parser = argparse.ArgumentParser(description='Decrypts IcedID from PNG image files downloaded by the IcedID loader component')
    parser.add_argument('filename', nargs='?', default='photo.png', help='PNG image file')
    parser.add_argument('-d', '--debug', action='store_true', help='Debug logging')
    args = parser.parse_args()

    print('[+] Input file: {}'.format(args.filename))
    with open(args.filename, 'rb') as f:
        data = f.read()

    assert struct.unpack_from('=I', data, 0x57)[0] == 0x54414449

    bufsize = struct.unpack_from('>I', data, 0x53)[0]
    assert bufsize < len(data)
    print('[+] Buffer size: {}'.format(bufsize))

    data = data[0x5b:0x5b + bufsize]

    rc4_key, data = data[:8], data[8:]
    print('[+] RC4 key: {}'.format(rc4_key.hex()))

    print('[+] Decrypting...')
    data = ARC4.new(rc4_key).decrypt(data)

    filename = args.filename + '.decrypted'
    print('[+] Saving decrypted shellcode: {}'.format(filename))
    with open(filename, 'wb') as f:
        f.write(data)

    magic, size, loader32, loader64, header32, header64 = struct.unpack_from('=IIIIII', data)
    assert len(data) == size

    if args.debug:
        print('---')
        print('Magic:', hex(magic))
        print('Size:', hex(size))
        print('Loader32:', hex(loader32))
        print('Loader64:', hex(loader64))
        print('Header32:', hex(header32))
        print('Header64:', hex(header64))
        print('---')

    for header in (header32, header64):
        if header == header32:
            arch = 32
        elif header == header64:
            arch = 64
        assert arch in (32, 64)

        image_base, size_of_image, entry_point, import_rva, fixups_rva, fixups_size, num_sections = struct.unpack_from('=QIIIIII', data, header)

        if args.debug:
            print('ImageBase:', hex(image_base))
            print('SizeOfImage:', hex(size_of_image))
            print('EntryPoint:', hex(entry_point))
            print('Import RVA:', hex(import_rva))
            print('Fixups RVA:', hex(fixups_rva))
            print('Fixups size:', hex(fixups_size))
            print('Number of sections:', hex(num_sections))
            print('---')

        sections = {}
        for i in range(num_sections):
            pos = 0x11*i + 0x20
            virtual_address, virtual_size, physical_offset, physical_size, flags = struct.unpack_from('=IIIIB', data, header + pos)

            start = header + physical_offset
            end = start + physical_size
            sections[virtual_address] = {
                'virtual_size': virtual_size,
                'virtual_address': virtual_address,
                'physical_size': physical_size,
                'physical_offset': physical_offset,
                'section_flags': flags,
                'section_data': data[start:end],
            }

        if arch == 32:
            PE_HEADER = PE32_HEADER
            section_offset = 0x178
        elif arch == 64:
            PE_HEADER = PE64_HEADER
            section_offset = 0x188

        size_of_code = 0
        size_of_init_data = 0
        size_of_uninit_data = 0
        import_size = 0

        # reconstruct PE file
        pefile = bytearray(PE_HEADER.ljust(0x400, b'\0'))

        next_rva = 0x1000
        for i, rva in enumerate(sorted(sections)):
            section = sections[rva]
            virtual_size = section['virtual_size']
            virtual_address = section['virtual_address']
            physical_size = section['physical_size']
            physical_offset = len(pefile)
            section_flags = section['section_flags']
            section_data = section['section_data']

            if next_rva < virtual_address:
                print('[!] WARNING: PE sections are not contiguous')

            if args.debug:
                print('Virtual address:', hex(virtual_address))
                print('Virtual size:', hex(virtual_size))
                print('Physical address:', hex(physical_offset))
                print('Physical size:', hex(physical_size))
                print('Flags:', hex(section_flags))
                print('---')

            if i == 0:
                # base of code
                struct.pack_into('=I', pefile, 0xac, virtual_address)
            elif i == 1 and arch == 32:
                # base of data
                struct.pack_into('=I', pefile, 0xb0, virtual_address)

            section_name = SECTION_NAMES[arch][i]
            if section_flags == 0x20:
                # read/execute, code
                section_flags = 0x60000020
            elif section_flags == 0x04:
                if section_name in ('.rdata', '.pdata', '.reloc'):
                    # read only, init data
                    section_flags = 0x40000040
                else:
                    # read/write, init data
                    section_flags = 0xc0000040
            else:
                # read/write, uninit data
                section_flags = 0xc0000080

            if section_flags & 0x20:
                size_of_code += round_up(virtual_size, 0x200)
            if section_flags & 0x40:
                size_of_init_data += round_up(virtual_size, 0x200)
            if section_flags & 0x80:
                size_of_uninit_data += round_up(virtual_size, 0x200)

            struct.pack_into('=8sIIIIIIHHI', pefile, section_offset + 0x28*i,
                section_name.encode().ljust(8, b'\0'),
                virtual_size,
                virtual_address,
                physical_size,
                physical_offset,
                0, 0, 0, 0,
                section_flags
            )

            pefile += bytearray(section_data.ljust(round_up(physical_size, 0x200), b'\0'))
            next_rva += round_up(virtual_size, 0x1000)

            if virtual_address <= import_rva < next_rva:
                # calculate import directory size
                import_size = round_up(len(section_data[import_rva - virtual_address:].split(b'\0' * 0x14, 1)[0]) + 0x14, 0x14)

        struct.pack_into('=H', pefile, 0x86, num_sections)
        struct.pack_into('=I', pefile, 0x9c, size_of_code)
        struct.pack_into('=I', pefile, 0xa0, size_of_init_data)
        struct.pack_into('=I', pefile, 0xa4, size_of_uninit_data)
        struct.pack_into('=I', pefile, 0xa8, entry_point)

        if arch == 32:
            struct.pack_into('=I', pefile, 0xb4, image_base)
            struct.pack_into('=II', pefile, 0x100, import_rva, import_size)
            struct.pack_into('=II', pefile, 0x120, fixups_rva, fixups_size)
        elif arch == 64:
            struct.pack_into('=Q', pefile, 0xb0, image_base)
            struct.pack_into('=II', pefile, 0x110, import_rva, import_size)
            struct.pack_into('=II', pefile, 0x130, fixups_rva, fixups_size)

        struct.pack_into('=I', pefile, 0xd0, size_of_image)

        filename = 'icedid{!s}.dll'.format(arch)
        print('[+] Saving reconstructed {}-bit payload: {}'.format(arch, filename))
        with open(filename, 'wb') as f:
            f.write(pefile)


if __name__ == '__main__':
    main()
